/*****************************************************************************
 * Project: RooFit                                                           
 * Package: BToDKTo3piK                                                     
 *    File: $Id: BdkSmear.cc,v 1.2 2006/03/17 01:13:57 fwinkl Exp $
 * Authors:                                                                  
 *   Frank Winklmeier, Colorado State University                             
 * Description:                                                              
 *   Class to smear a N-dim RooAbsPdf with M (M<=N) resolution PDFs          
 *   BdkSmear is not a fully functional RooAbsPdf itself.                    
 *   Only generate() can be used on it. I.e. does not support fitting.       
 *                                                                           
 * Copyright (c) 2006, Colorado State University                             
 *****************************************************************************/

#include "RooFitCore/RooFit.hh"

#include "Riostream.h"
#include "Riostream.h"

#include "BToDKTo3piK/BdkSmear.hh"

#include "RooFitCore/RooAbsReal.hh"
#include "RooFitCore/RooRealVar.hh"
#include "RooFitCore/RooRandom.hh"
#include "RooFitCore/RooDataSet.hh"
#include "RooFitCore/RooGenContext.hh"


using namespace std;

ClassImp(BdkSmear)

/// Constructor
/// Smear (convolute) the variables in pdfVars generated by pdf
/// with the variables in resVars generated from resModels
BdkSmear::BdkSmear(const char *name, const char *title,
                   RooAbsPdf& pdf, const RooArgSet& pdfVars,
                   const RooArgList& resModels, const RooArgList& resVars) :
  RooAbsPdf(name,title),
  _pdf("pdf","original PDF",this,pdf),
  _pdfVars("pdfVars","proxy list of PDF vars",this),
  _resModels("resModels","proxy list of resolution models",this),
  _resVars("resVars","proxy list of resolution variables",this)
{
  init();
  setEventBuffer();

  _pdfVars.add(pdfVars);

  // Do some basic checks
  
  if (resModels.getSize()!=resVars.getSize()) {
    cout << "BdkSmear::BdkSmear(" << GetName()
	 << ") Number of resolution models ("<<resModels.getSize()<<")"
	 << " is not equal to number of resolution variables ("
	 << resVars.getSize()<<")."
	 << endl;
    return;
  }
  
  for (Int_t i=0; i<resModels.getSize(); i++) {
    if (!dynamic_cast<RooAbsPdf*>(&resModels[i])) {
      cout << "BdkSmear::BdkSmear(" << GetName()
	   << ") pdf " << resModels[i].GetName()
	   << " is not of type RooAbsPdf. Ignored."
	   <<endl;
      continue;
    }
    if (!((RooAbsPdf&)resModels[i]).getParameters(RooArgSet())->contains(resVars[i])) {
      cout << "BdkSmear::BdkSmear(" << GetName()
	   << ") pdf " << resModels[i].GetName()
	   << " does not depend on "<<resVars[i].GetName() << " Ignored."
	   <<endl;
      continue;
    }
    _resModels.add(resModels[i]);
    _resVars.add(resVars[i]);
  }
}

/// Copy constructor
BdkSmear::BdkSmear(const BdkSmear& other, const char* name) : 
  RooAbsPdf(other,name),
  _pdf("pdf",this,other._pdf),
  _pdfVars("pdfVars",this,other._pdfVars),
  _resModels("resModels",this,other._resModels),
  _resVars("resVars",this,other._resVars),
  _events(other._events)
{
  init();
}

/// Destructor
BdkSmear::~BdkSmear()
{
  clearEventBuffer();
}

void BdkSmear::init()
{
  _pdfData = 0;
  _pdfEventsUsed = 0;
  clearEventBuffer();
}

void BdkSmear::clearEventBuffer()
{
  // Clean up old datasets
  delete _pdfData;
  _pdfData = 0;
  _pdfEventsUsed = 0;
  
  for (Int_t i=0; i<_resData.size(); i++) delete _resData[i];
  _resData.clear();
  _resEventsUsed.clear();

  // Initialize empty datasets
  _resData.insert(_resData.begin(),_resModels.getSize(),(RooDataSet*)0);
  _resEventsUsed.insert(_resEventsUsed.begin(),_resModels.getSize(),0);
}


/// Not supported by this PDF. Always returns 1.
Double_t BdkSmear::evaluate() const
{
  return 1;
}


/// Get generator context
RooAbsGenContext*
BdkSmear::genContext(const RooArgSet &vars, const RooDataSet *prototype, 
                     const RooArgSet* auxProto, Bool_t verbose) const 
{
  return new RooGenContext(*this,vars,prototype,auxProto,verbose,
			   &_pdfVars) ;
  //                         ^^^^^^
  //     This forces that our own generator is used for these variables
}


Int_t BdkSmear::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const
{
  if (matchArgs(directVars,generateVars,_pdfVars)) return 1 ;  
  return 0;
}


/// This gets called by RooAbsPdf::generate()
void BdkSmear::initGenerator(Int_t code)
{
  assert(code==1);
  clearEventBuffer();
}


/// Our own generator
void BdkSmear::generateEvent(Int_t code)
{
  assert(code==1) ;
        
  // generate PDF data if needed
  if (_pdfData==0 || _pdfEventsUsed >= _pdfData->numEntries()) {
    delete _pdfData;    
    _pdfData = ((RooAbsPdf*)_pdf.absArg())->generate(_pdfVars,_events);    
    _pdfEventsUsed = 0;
  }

  // get one entry from the PDF dataset
  RooArgSet vars(*_pdfData->get(_pdfEventsUsed++));

  // put these values into the proxies
  TIterator* iter = _pdfVars.createIterator();
  while (RooRealVar* r = (RooRealVar*)iter->Next()) {
    r->setVal(((RooRealVar*)vars.find(r->GetName()))->getVal());
  }
  
  // smear the values
  for (Int_t i=0; i<_resVars.getSize(); i++) {

    // pointer to PDF value we are modifying
    RooRealVar *r = (RooRealVar*)_pdfVars.find(_resVars[i].GetName());

    // get original value
    Double_t pdfVal = ((RooRealVar*)vars.find(_resVars[i].GetName()))->getVal();
    
    while (1) {

      // generate resolution data if needed
      if (_resData[i]==0 || _resEventsUsed[i] >= _resData[i]->numEntries()) {
        delete _resData[i];
        _resData[i] = ((RooAbsPdf&)_resModels[i]).generate(_resVars[i],_events);
        _resEventsUsed[i] = 0;
      }

      // get one entry from resolution dataset
      Double_t resVal = ((RooRealVar*)_resData[i]->get(_resEventsUsed[i]++)->first())->getVal();

      // new value
      Double_t smearVal = pdfVal + resVal;

      // Check if the new value is within the range
      if (smearVal<r->getMax() && smearVal>r->getMin()) {
        r->setVal(smearVal);        
        break;
      }
    }
  }
}


